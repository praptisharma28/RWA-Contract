diff --git a/rwa-contract/rwa-contract/programs/rwa-contract/Cargo.toml b/rwa-contract/rwa-contract/programs/rwa-contract/Cargo.toml
index 6da5669..7c589fb 100644
--- a/rwa-contract/rwa-contract/programs/rwa-contract/Cargo.toml
+++ b/rwa-contract/rwa-contract/programs/rwa-contract/Cargo.toml
@@ -16,7 +16,6 @@ no-idl = []
 no-log-ix-name = []
 idl-build = ["anchor-lang/idl-build"]
 
-
 [dependencies]
 anchor-lang = "0.31.1"
-
+anchor-spl = "0.31.1"
diff --git a/rwa-contract/rwa-contract/programs/rwa-contract/src/auction.rs b/rwa-contract/rwa-contract/programs/rwa-contract/src/auction.rs
index 8f57fbb..ecf395a 100644
--- a/rwa-contract/rwa-contract/programs/rwa-contract/src/auction.rs
+++ b/rwa-contract/rwa-contract/programs/rwa-contract/src/auction.rs
@@ -2,18 +2,144 @@ use anchor_lang::prelude::*;
 
 use crate::state::*;
 use crate::errors::ErrorCode;
+use crate::events::{DutchAuctionCreated, BidPlaced};
+use crate::access_control::has_role;
 
+pub fn create_dutch_auction(
+    ctx: Context<CreateDutchAuction>,
+    start_price: u64,
+    end_price: u64,
+    duration_seconds: i64,
+    tokens_for_sale: u64,
+) -> Result<()>{
+    require!(has_role(&ctx.accounts.auction_authority_role, &ctx.accounts.authority.key(), "AUCTION_AUTHORITY"),
+    ErrorCode::InsufficientPermissions
+    );
+    let auction = &mut ctx.accounts.auction;
+    let current_time = Clock::get()?.unix_timestamp;
+    auction.seller = ctx.accounts.seller.key();
+    auction.token_mint = ctx.accounts.token_mint.key();
+    auction.start_price = start_price;
+    auction.end_price= end_price;
+    auction.start_time= current_time;
+    auction.end_time= current_time+duration_seconds;
+    auction.tokens_for_sale= tokens_for_sale;
+    auction.tokens_sold= 0;
+    auction.is_active = true;
+    auction.bump = ctx.bumps.auction;
+    emit!(DutchAuctionCreated{
+        auction: auction.key(),
+        seller: auction.seller,
+        start_price,
+        end_price,
+        duration_seconds,
+        tokens_for_sale,
+        timestamp: current_time,
+    });
+    Ok(())
+}
+
+pub fn place_bid(
+    ctx: Context<PlaceBid>,
+    token_amount: u64,
+) -> Result<()>{
+    let auction = &mut ctx.accounts.auction;
+    let current_time= Clock::get()?.unix_timestamp;
+    require!(auction.is_active , ErrorCode::AuctionNotActive);
+    require!(current_time <= auction.end_time, ErrorCode::AuctionExpired);
+    require!(token_amount <= auction.tokens_for_sale - auction.tokens_sold, ErrorCode::InsufficientTokensAvailable);
+    let current_price = calculate_dutch_auction_price(
+        auction.start_price,
+        auction.end_price,
+        auction.start_time,
+        auction.end_time,
+        current_time,
+    );
 
+    let total_cost = current_price.checked_mul(token_amount).unwrap();
+    auction.tokens_sold = auction.tokens_sold.checked_add(token_amount).unwrap();
+    if auction.tokens_sold >= auction.tokens_for_sale{
+        auction.is_active = false;
+    }
+
+    emit!(BidPlaced{
+    auction: auction.key(),
+    bidder: ctx.accounts.bidder.key(),
+    token_amount,
+    price_per_token: current_price,
+    total_cost,
+    timestamp: current_time,
+    });
+    Ok(())
+}
+
+pub fn calculate_dutch_auction_price(
+    start_price: u64,
+    end_price: u64,
+    start_time: i64,
+    end_time: i64,
+    current_time: i64,
+) -> u64{
+    if current_time >= end_time{
+        return end_price;
+    }
+    let total_duration = end_time- start_time;
+    let elapsed_time = current_time- start_time;
+    let price_decay= (start_price-end_price) * elapsed_time  as u64/ total_duration as u64;
+    start_price - price_decay 
+}
+
+#[derive(Accounts)]
+pub struct CreateDutchAuction<'info>{
+    #[account(
+        init,
+        payer = payer,
+        space = 8 + 32 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 1,
+        seeds = [b"dutch_auction", seller.key().as_ref(), token_mint.key().as_ref()],
+        bump
+    )]
+    pub auction: Account<'info, DutchAuction>,
+
+    #[account(
+        seeds= [b"user_role", b"AUCTION_AUTHORITY"],
+        bump = auction_authority_role.bump
+    )]
+    pub auction_authority_role: Account<'info, UserRole>,
+    pub seller: AccountInfo<'info>,
+    pub token_mint: AccountInfo<'info>,
+    pub authority: Signer<'info>,
+
+    #[account(mut)]
+    pub payer: Signer<'info>,
+    pub system_program: Program<'info, System>,
+
+}
+
+#[derive(Accounts)]
+pub struct PlaceBid<'info> {
+    #[account(
+        mut,
+        seeds= [b"dutch_auction", auction.seller.as_ref(), auction.token_mint.as_ref()],
+        bump = auction.bump
+    )]
+    pub auction: Account<'info, DutchAuction>,
+    pub bidder: Signer<'info>,
+}use anchor_lang::prelude::*;
+
+use crate::state::*;
+use crate::errors::ErrorCode;
+use crate::events::{DutchAuctionCreated, BidPlaced};
+use crate::access_control::has_role;
 
 pub fn create_dutch_auction(
-    ctx: Context<ContextDutchAuction>,
+    ctx: Context<CreateDutchAuction>,
     start_price: u64,
     end_price: u64,
     duration_seconds: i64,
     tokens_for_sale: u64,
 ) -> Result<()>{
-    require!(has_role(&ctx.accounts.auction_authority_role, &ct.accounts.authority.key(), "AUCTION_AUTHORITY"),
-    ErrorCode::
+    require!(has_role(&ctx.accounts.auction_authority_role, &ctx.accounts.authority.key(), "AUCTION_AUTHORITY"),
+    ErrorCode::InsufficientPermissions
     );
     let auction = &mut ctx.accounts.auction;
     let current_time = Clock::get()?.unix_timestamp;
@@ -39,16 +165,15 @@ pub fn create_dutch_auction(
     Ok(())
 }
 
-
 pub fn place_bid(
     ctx: Context<PlaceBid>,
     token_amount: u64,
 ) -> Result<()>{
     let auction = &mut ctx.accounts.auction;
     let current_time= Clock::get()?.unix_timestamp;
-    require!(auction.is_active , ErrorCode::);
-    require!(current_time <= auction.end_time, ErrorCode);
-    require!(token_amount <= auction.tokens_for_sale - auction.tokens_sold, ErrorCode);
+    require!(auction.is_active , ErrorCode::AuctionNotActive);
+    require!(current_time <= auction.end_time, ErrorCode::AuctionExpired);
+    require!(token_amount <= auction.tokens_for_sale - auction.tokens_sold, ErrorCode::InsufficientTokensAvailable);
     let current_price = calculate_dutch_auction_price(
         auction.start_price,
         auction.end_price,
@@ -57,9 +182,9 @@ pub fn place_bid(
         current_time,
     );
 
-    let total_cost = current_price.checked_mul(token_account).unwrap();
-    auction.token_sold = auction.token_sold.checked_add(token_account).unwrap();
-    if auction.token_sold >= auction.tokens_for_sale{
+    let total_cost = current_price.checked_mul(token_amount).unwrap();
+    auction.tokens_sold = auction.tokens_sold.checked_add(token_amount).unwrap();
+    if auction.tokens_sold >= auction.tokens_for_sale{
         auction.is_active = false;
     }
 
@@ -95,8 +220,8 @@ pub struct CreateDutchAuction<'info>{
     #[account(
         init,
         payer = payer,
-        space =
-        seeds = [b"dutch_auction", seller.key().as_ref(), token_mint.key().as_bytes()],
+        space = 8 + 32 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 1,
+        seeds = [b"dutch_auction", seller.key().as_ref(), token_mint.key().as_ref()],
         bump
     )]
     pub auction: Account<'info, DutchAuction>,
@@ -120,9 +245,9 @@ pub struct CreateDutchAuction<'info>{
 pub struct PlaceBid<'info> {
     #[account(
         mut,
-        seeds= [b"dutch_auction", auction_seller.as_ref(), auction.token_mint.as_ref()],
+        seeds= [b"dutch_auction", auction.seller.as_ref(), auction.token_mint.as_ref()],
         bump = auction.bump
     )]
     pub auction: Account<'info, DutchAuction>,
     pub bidder: Signer<'info>,
-}
\ No newline at end of file
+}
diff --git a/rwa-contract/rwa-contract/programs/rwa-contract/src/carbon_credits.rs b/rwa-contract/rwa-contract/programs/rwa-contract/src/carbon_credits.rs
index a75fbc3..417b764 100644
--- a/rwa-contract/rwa-contract/programs/rwa-contract/src/carbon_credits.rs
+++ b/rwa-contract/rwa-contract/programs/rwa-contract/src/carbon_credits.rs
@@ -1,6 +1,5 @@
 use anchor_lang::prelude::*;
-use anchor_spl::token_2022::{self, Token2022, TokenAccount, Mint};
-use anchor_spl::token_interface::{TokenInterface, MintTo, mint_to};
+use anchor_spl::token_interface::{TokenInterface, MintTo, mint_to, TokenAccount, Mint};
 use anchor_spl::associated_token::AssociatedToken;
 
 use crate::state::*;
@@ -94,7 +93,7 @@ pub struct InitializeCarbonToken<'info> {
         mint::decimals = 0,
         mint::authority = authority,
     )]
-    pub mint: Account<'info, Mint>,
+    pub mint: InterfaceAccount<'info, Mint>,
     
     #[account(
         seeds = [b"user_role", b"MINT_AUTHORITY"],
@@ -106,7 +105,7 @@ pub struct InitializeCarbonToken<'info> {
     
     #[account(mut)]
     pub payer: Signer<'info>,
-    pub token_program: Program<'info, Token2022>,
+    pub token_program: Interface<'info, TokenInterface>,
     pub system_program: Program<'info, System>,
 }
 
@@ -120,14 +119,15 @@ pub struct MintCarbonCredits<'info> {
     pub carbon_token: Account<'info, CarbonToken>,
     
     #[account(mut)]
-    pub mint: Account<'info, Mint>,
+    pub mint: InterfaceAccount<'info, Mint>,
     
     #[account(
         mut,
         associated_token::mint = mint,
         associated_token::authority = recipient,
+        associated_token::token_program = token_program,
     )]
-    pub token_account: Account<'info, TokenAccount>,
+    pub token_account: InterfaceAccount<'info, TokenAccount>,
     
     #[account(
         seeds = [b"user_role", b"MINT_AUTHORITY"],
@@ -138,5 +138,7 @@ pub struct MintCarbonCredits<'info> {
     pub recipient: AccountInfo<'info>,
     
     pub mint_authority: Signer<'info>,
-    pub token_program: Program<'info, Token2022>,
-}
\ No newline at end of file
+    pub token_program: Interface<'info, TokenInterface>,
+    pub associated_token_program: Program<'info, AssociatedToken>,
+    pub system_program: Program<'info, System>,
+}
diff --git a/rwa-contract/rwa-contract/programs/rwa-contract/src/industry.rs b/rwa-contract/rwa-contract/programs/rwa-contract/src/industry.rs
index 1ab6a74..d8c3474 100644
--- a/rwa-contract/rwa-contract/programs/rwa-contract/src/industry.rs
+++ b/rwa-contract/rwa-contract/programs/rwa-contract/src/industry.rs
@@ -1,113 +1,125 @@
 use anchor_lang::prelude::*;
-use anchor_spl::token_2022::TokenAccount;
+use anchor_spl::token_interface::TokenAccount;
+
+use crate::state::*;
+use crate::events::{IndustryOnboarded, EmissionsReported};
+use crate::access_control::has_role;
+use crate::errors::ErrorCode;
 
 pub fn onboard_industry(
-    ctx:Context<OnboardIndustry>,
+    ctx: Context<OnboardIndustry>,
     company_name: String,
-    registeration_number: String,
+    registration_number: String,
     bond_amount: u64,
 ) -> Result<()> {
-    require!(has_role(&ctx.accounts.kyc_authority_role, &ctx.accounts.authority.key(), "KYC_AUTHORITY"),
-    ErrorCode::);
+    require!(
+        has_role(&ctx.accounts.kyc_authority_role, &ctx.accounts.authority.key(), "KYC_AUTHORITY"),
+        ErrorCode::InsufficientPermissions
+    );
 
     let industry = &mut ctx.accounts.industry;
     industry.authority = ctx.accounts.industry_authority.key();
-    industry.company_name = company_name;
-    industry.registeration_number= registeration_number;
-    industry.bond_amount= bond_amount;
+    industry.company_name = company_name.clone();
+    industry.registration_number = registration_number.clone();
+    industry.bond_amount = bond_amount;
     industry.is_kyc_verified = true;
     industry.is_active = true;
     industry.total_emissions = 0;
     industry.credits_burned = 0;
     industry.compliance_status = ComplianceStatus::Compliant;
     industry.onboarding_date = Clock::get()?.unix_timestamp;
-    industry.bump= ctx.bumps.industry;
+    industry.bump = ctx.bumps.industry;
     
-    emit!(IndustryOnboarded{
+    emit!(IndustryOnboarded {
         industry: ctx.accounts.industry_authority.key(),
-        company_name:industry.company_name.clone(),
+        company_name,
         bond_amount,
-        timestamp: industry.onboard_date,
+        timestamp: industry.onboarding_date,
     });
 
-    Ok()
+    Ok(())
 }
 
 pub fn report_emissions(
-    ctx:Context<ReportEmissions>,
+    ctx: Context<ReportEmissions>,
     co2_tonnes: u64,
     reporting_period: String,
 ) -> Result<()> {
     let industry = &mut ctx.accounts.industry;
-    require!(industry.is_active, ErrorCode::);
-    require!(industry.authority ==ctx.accounts.industry_authority.key())
+    require!(industry.is_active, ErrorCode::IndustryNotActive);
+    require!(industry.authority == ctx.accounts.industry_authority.key(), ErrorCode::Unauthorized);
+    
     industry.total_emissions = industry.total_emissions.checked_add(co2_tonnes).unwrap();
     let current_balance = ctx.accounts.industry_token_account.amount;
-    if current_balance >= co2_tonnes{
+    
+    if current_balance >= co2_tonnes {
         industry.credits_burned = industry.credits_burned.checked_add(co2_tonnes).unwrap();
 
-        emit!(EmissionsReported{
-            industry:ctx.accounts.industry_authority.key(),
+        emit!(EmissionsReported {
+            industry: ctx.accounts.industry_authority.key(),
             co2_tonnes,
-            credits_burned:co2_tonnes,
-            reporting_period,
+            credits_burned: co2_tonnes,
+            reporting_period: reporting_period.clone(),
             compliance_status: ComplianceStatus::Compliant,
             timestamp: Clock::get()?.unix_timestamp,
         });
-    else {
+    } else {
         industry.compliance_status = ComplianceStatus::NonCompliant;
-        emit!(EmissionsReported{
-            industry:ctx.accounts.industry_authority.key(),
+        emit!(EmissionsReported {
+            industry: ctx.accounts.industry_authority.key(),
             co2_tonnes,
-            credits_burned:current_balance,
+            credits_burned: current_balance,
             reporting_period,
             compliance_status: ComplianceStatus::NonCompliant,
             timestamp: Clock::get()?.unix_timestamp,
         });
     }
+    
     Ok(())
 }
 
-
-
 #[derive(Accounts)]
-#[instruction()]
-pub struct OnboardIndustry<'info>{
+#[instruction(company_name: String, registration_number: String)]
+pub struct OnboardIndustry<'info> {
     #[account(
         init,
         payer = payer,
-        space = 8 + 
+        space = 8 + 32 + 4 + company_name.len() + 4 + registration_number.len() + 8 + 1 + 1 + 8 + 8 + 1 + 8 + 1,
         seeds = [b"industry", industry_authority.key().as_ref()],
         bump
     )]
     pub industry: Account<'info, Industry>,
+    
     #[account(
-        seeds = [b"user_role",b"KYC_AUTHORITY" ],
+        seeds = [b"user_role", b"KYC_AUTHORITY"],
         bump = kyc_authority_role.bump
     )]
     pub kyc_authority_role: Account<'info, UserRole>,
+    
     pub industry_authority: AccountInfo<'info>,
     pub authority: Signer<'info>,
+    
+    #[account(mut)]
     pub payer: Signer<'info>,
+    
     pub system_program: Program<'info, System>,
 }
 
 #[derive(Accounts)]
-#[instruction()]
-pub struct ReportEmissions<'info>{
+pub struct ReportEmissions<'info> {
     #[account(
         mut,
         seeds = [b"industry", industry_authority.key().as_ref()],
         bump = industry.bump
     )]
     pub industry: Account<'info, Industry>,
+    
     #[account(
         associated_token::mint = token_mint,
-        associated_token::authority= industry_authority,
+        associated_token::authority = industry_authority,
     )]
-    pub industry_token_account: Account<'info, TokenAccount>,
-    pub token_mint: Account<'info>,
+    pub industry_token_account: InterfaceAccount<'info, TokenAccount>,
+    
+    pub token_mint: AccountInfo<'info>,
     pub industry_authority: Signer<'info>,
 }
-
-
diff --git a/rwa-contract/rwa-contract/programs/rwa-contract/src/lib.rs b/rwa-contract/rwa-contract/programs/rwa-contract/src/lib.rs
index 9e4c13a..80523d7 100644
--- a/rwa-contract/rwa-contract/programs/rwa-contract/src/lib.rs
+++ b/rwa-contract/rwa-contract/programs/rwa-contract/src/lib.rs
@@ -1,25 +1,22 @@
 use anchor_lang::prelude::*;
 
-mod access_control;
-mod carbon_credits;
-mod industry;
-mod auction;
-mod state;
-mod events;
-mod errors;
+pub mod access_control;
+pub mod carbon_credits;
+pub mod industry;
+pub mod auction;
+pub mod state;
+pub mod events;
+pub mod errors;
 
 use access_control::*;
 use carbon_credits::*;
 use industry::*;
 use auction::*;
-use state::*;
-use events::*;
-use errors::*;
 
 declare_id!("4gBj3avgtDybWri9xiDQt7D3yaTiz3KbUysbVKq8Fcd4");
 
 #[program]
-pub mod carbon_rwa {
+pub mod rwa_contract {
     use super::*;
 
     pub fn initialize_access_control(
@@ -30,15 +27,15 @@ pub mod carbon_rwa {
     }
 
     pub fn create_role(
-        ctx:Context<CreateRole>,
-        role_name:String,
-        actions:Vec<String>,
+        ctx: Context<CreateRole>,
+        role_name: String,
+        actions: Vec<String>,
     ) -> Result<()> {
         access_control::create_role(ctx, role_name, actions)
     }
 
     pub fn assign_user_to_role(
-        ctx:Context<AssignUserToRole>,
+        ctx: Context<AssignUserToRole>,
         user: Pubkey,
     ) -> Result<()> {
         access_control::assign_user_to_role(ctx, user)
@@ -46,12 +43,12 @@ pub mod carbon_rwa {
 
     pub fn initialize_carbon_token(
         ctx: Context<InitializeCarbonToken>,
-        name:String,
+        name: String,
         symbol: String,
-        uri:String,
+        uri: String,
         co2_tonnes: u64,
-        project_id:String,
-        expiry_date:i64,
+        project_id: String,
+        expiry_date: i64,
         issuer_name: String,
     ) -> Result<()> {
         carbon_credits::initialize_carbon_token(
@@ -68,7 +65,7 @@ pub mod carbon_rwa {
 
     pub fn mint_carbon_credits(
         ctx: Context<MintCarbonCredits>,
-        amount:u64,
+        amount: u64,
     ) -> Result<()> {
         carbon_credits::mint_carbon_credits(ctx, amount)
     }
@@ -84,7 +81,7 @@ pub mod carbon_rwa {
 
     pub fn report_emissions(
         ctx: Context<ReportEmissions>,
-        co2_tonnes:u64,
+        co2_tonnes: u64,
         reporting_period: String,
     ) -> Result<()> {
         industry::report_emissions(ctx, co2_tonnes, reporting_period)
@@ -92,9 +89,9 @@ pub mod carbon_rwa {
 
     pub fn create_dutch_auction(
         ctx: Context<CreateDutchAuction>,
-        start_price:u64,
+        start_price: u64,
         end_price: u64,
-        duration_seconds:i64,
+        duration_seconds: i64,
         tokens_for_sale: u64,
     ) -> Result<()> {
         auction::create_dutch_auction(ctx, start_price, end_price, duration_seconds, tokens_for_sale)
@@ -102,7 +99,7 @@ pub mod carbon_rwa {
 
     pub fn place_bid(
         ctx: Context<PlaceBid>,
-        token_amount:u64,
+        token_amount: u64,
     ) -> Result<()> {
         auction::place_bid(ctx, token_amount)
     }
